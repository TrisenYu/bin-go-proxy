// SPDX-LICENSE-IDENTIFIER: GPL-2.0-Only
// (C) 2024 Author: <kisfg@hotmail.com>
package client

import (
	"crypto/rand"
	"errors"
	"time"

	config "bingoproxy/config"
	cryptoprotect "bingoproxy/cryptoProtect"
	asymmetricciphers "bingoproxy/cryptoProtect/asymmetricCiphers"
	hashciphers "bingoproxy/cryptoProtect/hashCiphers"
	streamciphers "bingoproxy/cryptoProtect/streamCiphers"
	zipper "bingoproxy/cryptoProtect/zipper"
	defErr "bingoproxy/defErr"
	protocol "bingoproxy/protocol"
	service "bingoproxy/service"
	utils "bingoproxy/utils"
)

/*
invoke this after gaining the proxy pubkey.

	serialize the handshake-msg into bytes and encrypt with proxy's pubkey.
*/
func (c *Client) pPubEncryptHandShakeMsg(handshake *protocol.HandShakeMsg) ([]byte, error) {
	serialization := make([]byte, 0)
	serialization = append(serialization, utils.Uint64ToLittleEndianBytes(handshake.Nonce)...)
	serialization = append(serialization, handshake.Kern...)
	serialization = append(serialization, handshake.Hasher...)
	serialization = append(serialization, handshake.Signature...)
	serialization = append(serialization, handshake.Timestamp...)
	encrypt_msg, err := c.ProxyAsymmCipher.PubEncrypt(serialization)
	return encrypt_msg, err
}

/* invoke this after generating pubkey */
func (c *Client) generateRN() (*protocol.HandShakeMsg, error) {
	var (
		nonce_ed uint64 = 8 // nonce is defined as 8 bytes
		iv_ed           = nonce_ed + c.KeyLen + c.IvLen
	)
	rn := make([]byte, iv_ed-nonce_ed)
	_, err := rand.Reader.Read(rn)
	if err != nil {
		return nil, err
	}
	nonceIn64, nonce, err := protocol.GenerateRandUint64WithByteRepresentation()
	if err != nil {
		return nil, err
	}

	timeStamp := []byte(protocol.SafeResetLen())
	kern := []byte(nonce)
	kern = append(kern, rn...)
	kern = append(kern, timeStamp...)

	var (
		hasher    = c.HashCipher.CalculateHash(kern)
		signature = make([]byte, c.AsymmCipher.GetSignatureLen())
	)
	_signature, err := c.AsymmCipher.PemSign(hasher)
	if err != nil {
		return nil, err
	}
	copy(signature, _signature)
	client_hello := protocol.HandShakeMsg{
		Nonce:     nonceIn64,
		Kern:      rn,
		Hasher:    hasher,
		Signature: signature,
		Timestamp: timeStamp,
	}
	return &client_hello, nil
}

// Hard-encode HandShakeMsg.
func (c *Client) extractHandShakeMsg(msg []byte) (*protocol.HandShakeMsg, error) {
	var (
		nonce_ed uint64 = 8 // nonce is defined as 8 bytes
		iv_ed           = nonce_ed + c.KeyLen + c.IvLen
		hash_ed         = iv_ed + c.HashCipher.GetHashLen()
		sign_ed         = hash_ed + c.AsymmCipher.GetSignatureLen()
	)
	if uint64(len(msg))-sign_ed != protocol.SafeReadTimeLen() {
		return &protocol.HandShakeMsg{}, errors.New(protocol.PROXY_FAKE_HANDSHAKE)
	}

	var handshakemsg protocol.HandShakeMsg = protocol.HandShakeMsg{
		Nonce:     utils.LittleEndianBytesToUint64([8]byte(msg[:nonce_ed])),
		Kern:      msg[nonce_ed:iv_ed],
		Hasher:    msg[iv_ed:hash_ed],
		Signature: msg[hash_ed:sign_ed],
		Timestamp: msg[sign_ed:],
	}

	return &handshakemsg, nil
}

/*
TODO: Remote handshake.

Client or Proxy will directly disconnect if any error emerges during Stage handshake.

Client send clientHello to login proxy.
	clientHello contains a crypto-suite number which indicates the corresponding crypto algorithms to be
	utilized and a access-token generated by login proxy beforehand.

Once the access-token is verified, proxy will generate its (pri, pub) key pair and send the pub key to client and wait for ack.
Otherwise this connection will be immediately aborted. This method is suitable for subsequent use.

After client acknowleges the PPUB, Client should send CPUB to proxy and wait for ack.
Once receiving ack, then generates a handshake-Msg and divides it into two parts, and the first part will possess 50~60 percent.

Send each part sequentially while receiving the proxy-handshakeMsg and wait for corresponding ack and verify the validation.

And then generate session key from the message and send `finish` to proxy and wait for proxy response.
*/

func (c *Client) SendClientHelloPayload(asym_cfg, flow_cfg, hash_cfg, zip_cfg, access_token string) error {
	var choice uint32 = 0x0000_0000

	switch asym_cfg {
	case `sm2`:
		fallthrough
	default:
		choice |= uint32(cryptoprotect.PICK_SM2)
		c.AsymmCipher = &asymmetricciphers.SM2{}
		c.ProxyAsymmCipher = &asymmetricciphers.SM2{}
		c.AsymmCipher.GenerateKeyPair()
	}

	switch flow_cfg {
	case `salsa20`:
		choice |= uint32(cryptoprotect.PICK_SALSA20) << 8
		c.StreamCipher = &streamciphers.Salsa20{}
	case `aes-ofb-256`:
		choice |= uint32(cryptoprotect.PICK_AES_OFB_256) << 8
		c.StreamCipher = &streamciphers.AES_OFB_256{}
	case `aes-ctr-256`:
		choice |= uint32(cryptoprotect.PICK_AES_CTR_256) << 8
		c.StreamCipher = &streamciphers.AES_CTR_256{}
	case `aes-gcm-256`: // not recommanded?
		choice |= uint32(cryptoprotect.PICK_AES_GCM_256) << 8
		c.StreamCipher = &streamciphers.AES_GCM_256{}
	case `sm4-ofb-256`:
		choice |= uint32(cryptoprotect.PICK_SM4_OFB_128) << 8
		c.StreamCipher = &streamciphers.SM4_OFB{}
	case `sm4-ctr-256`:
		choice |= uint32(cryptoprotect.PICK_SM4_CTR_128) << 8
		c.StreamCipher = &streamciphers.SM4_CTR{}
	case `sm4-gcm-256`:
		choice |= uint32(cryptoprotect.PICK_SM4_GCM_128) << 8
		c.StreamCipher = &streamciphers.SM4_GCM{}
	case `chacha20poly1305`:
		choice |= uint32(cryptoprotect.PICK_CHACHA20POLY1305_256) << 8
		c.StreamCipher = &streamciphers.Chacha20poly1305{}
	case `zuc`:
		fallthrough
	default:
		choice |= uint32(cryptoprotect.PICK_ZUC) << 8
		c.StreamCipher = &streamciphers.ZUC{}
	}

	c.KeyLen, c.IvLen = c.StreamCipher.GetKeyLen(), c.StreamCipher.GetIvLen()

	switch hash_cfg {
	case `sha256`:
		choice |= uint32(cryptoprotect.PICK_SHA256) << 16
		c.HashCipher = &hashciphers.Sha256{}
	case `sha3-256`:
		choice |= uint32(cryptoprotect.PICK_SHA3_256) << 16
		c.HashCipher = &hashciphers.Sha3_256{}
	case `sha384`:
		choice |= uint32(cryptoprotect.PICK_SHA256) << 16
		c.HashCipher = &hashciphers.Sha256{}
	case `sha3-384`:
		choice |= uint32(cryptoprotect.PICK_SHA3_384) << 16
		c.HashCipher = &hashciphers.Sha3_384{}
	case `sha512`:
		choice |= uint32(cryptoprotect.PICK_SHA512) << 16
		c.HashCipher = &hashciphers.Sha512{}
	case `sha3-512`:
		choice |= uint32(cryptoprotect.PICK_SHA3_512) << 16
		c.HashCipher = &hashciphers.Sha3_512{}
	case `blake2b256`:
		choice |= uint32(cryptoprotect.PICK_BLAKE2B256) << 16
		c.HashCipher = &hashciphers.Blake2b256{}
	case `blake2s256`:
		choice |= uint32(cryptoprotect.PICK_BLAKE2S256) << 16
		c.HashCipher = &hashciphers.Blake2s256{}
	case `blake2b384`:
		choice |= uint32(cryptoprotect.PICK_BLAKE2B384) << 16
		c.HashCipher = &hashciphers.Blake2b384{}
	case `blake2b512`:
		choice |= uint32(cryptoprotect.PICK_BLAKE2B512) << 16
		c.HashCipher = &hashciphers.Blake2b512{}

	case `sm3`:
		fallthrough
	default:
		choice |= uint32(cryptoprotect.PICK_SM3) << 16
		c.HashCipher = &hashciphers.SM3{}
	}

	switch zip_cfg {
	case `zlib`:
		choice |= uint32(cryptoprotect.PICK_ZLIB_COMP) << 24
		c.CompOption = &zipper.Zlib{}
	case `null`:
		fallthrough
	default:
		choice |= uint32(cryptoprotect.PICK_NULL_COMP) << 24
		c.CompOption = &zipper.IdCompress{}
	}
	/* payload: {choice||token} */
	res := make([]byte, 4+len(access_token))
	copy(res[:4], utils.Uint32ToLittleEndianBytes(choice))
	copy(res[4:], []byte(access_token))

	cnt, err := c.MiProxy.Write(res)
	if cnt != uint(len(res)) || err != nil {
		err = defErr.StrConcat(`payload-len-mismatch or err:`, err)
	}
	return err
}

// step 1 wait for PPUB
func (c *Client) readStep1() error {
	shutdown := func() {
		c.wNeedBytes <- []byte{}
		c.MiProxy.CloseAll()
	}
	ppub, _, err := c.MiProxy.Read()
	if err != nil {
		shutdown()
		return defErr.StrConcat(protocol.FAILED_TO_RECV_COMPRESSED_PPUB, err)
	}
	dep, err := c.CompOption.DecompressMsg(ppub)
	if err != nil {
		shutdown()
		return err
	}
	c.wNeedBytes <- dep
	return nil
}

// step 1 ack PPUB
func (c *Client) writeStep1() error {
	ppub := <-c.wNeedBytes
	if uint64(len(ppub)) != c.AsymmCipher.GetPubLen() {
		c.MiProxy.CloseAll()
		return errors.New(protocol.INVALID_PPUB_LENGTH)
	}

	c.ProxyAsymmCipher.SetPub(ppub)
	// time.Sleep(time.Microsecond * 500)

	now, res := protocol.AckToTimestampHash(c.HashCipher, []byte(protocol.ACKPPUB))
	// TODO: compress the ack-pub?
	cnt, err := c.MiProxy.Write(append(now, res...))
	if uint64(cnt) != protocol.SafeGainTimestampHashLen() || err != nil {
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.FAILED_TO_SEND_ACKPPUB, err)
	}
	return nil
}

// step 2 wait for ack CPUB
func (c *Client) readStep2() error {
	ackcpub, _, err := c.MiProxy.Read()
	if !protocol.AckFlowValidation(
		c.HashCipher, ackcpub, []byte(protocol.ACKCPUB),
		c.ackTimCheck, &c.ackRec, c.pingRef, false) {
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.FAILED_TO_VALIDATE_ACKCPUB, err)
	}
	return nil
}

// step 2 send CPUB
func (c *Client) writeStep2() error {
	// time.Sleep(time.Microsecond * 500)
	if err := c.sendPub(); err != nil {
		c.MiProxy.CloseAll()
		return err
	}
	return nil
}

// step3 send and wait for ack of cflow1 | cflow2
func (c *Client) writeStep3(cflow []byte, turn int) error {
	time.Sleep(time.Microsecond * 500)
	// TODO: time sensitive and can we use another way to fend off side-channel attack?
	cf, err := c.CompOption.CompressMsg(cflow)
	if err != nil {
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.FAILED_TO_COMPRESS_CFLOW, err)
	}
	cnt, err := c.MiProxy.Write(cf)
	if err != nil || cnt != uint(len(cf)) {
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.FAILED_TO_SEND_COMPRESSED_CFLOW, err)
	}
	cack := <-c.wNeedBytes
	var choice []byte
	switch turn {
	case 1:
		choice = []byte(protocol.ACKCPK1)
	case 2:
		choice = []byte(protocol.ACKCPK2)
	default:
		return errors.New(protocol.C_PREFIX + protocol.BILATERY_INVALID_ACKCFLOW)
	}
	if !protocol.AckFlowValidation(c.HashCipher, cack, choice, c.ackTimCheck, &c.ackRec, c.pingRef, true) {
		c.MiProxy.CloseAll()
		return errors.New(protocol.FAILED_TO_PARSE_ACKCFLOW)
	}
	return nil
}

// step3 wait for ackcflow1 | ackcflow2
func (c *Client) readStep3() error {
	ackcpk, cnt, err := c.MiProxy.Read()
	currLen := protocol.SafeGainTimestampHashLen()
	if uint64(cnt) != currLen || err != nil {
		c.wNeedBytes <- []byte{}
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.FAILED_TO_PARSE_ACKCFLOW, err)
	}
	c.wNeedBytes <- ackcpk
	return nil
}

// step3 ack pflow1 | pflow2
func (c *Client) writeStep4(turn int) error {
	var choice []byte
	switch turn {
	case 1:
		choice = []byte(protocol.ACKPPK1)
	case 2:
		choice = []byte(protocol.ACKPPK2)
	default:
		return errors.New(protocol.C_PREFIX + protocol.BILATERY_INVALID_ACKPFLOW)
	}
	if !<-c.rDoneSignal {
		c.MiProxy.CloseAll()
		return errors.New(protocol.C_PREFIX + protocol.BILATERY_INNER_SIGNAL_FAILED)
	}
	now, res := protocol.AckToTimestampHash(c.HashCipher, choice)
	cnt, err := c.MiProxy.Write(append(now, res...))
	if uint64(cnt) != protocol.SafeGainTimestampHashLen() || err != nil {
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.FAILED_TO_SEND_ACKPFLOW, err)
	}
	return nil
}

// step3 read pflow1 | pflow2
func (c *Client) readStep4() ([]byte, error) {
	shutdown := func(err error) ([]byte, error) {
		c.rDoneSignal <- false
		c.MiProxy.CloseAll()
		return []byte{}, err
	}
	pf, _, err := c.MiProxy.Read()
	if err != nil {
		return shutdown(err)
	}
	pflow, err := c.CompOption.DecompressMsg(pf)
	if err != nil {
		return shutdown(err)
	}
	c.rDoneSignal <- true
	return pflow, nil
}

func (c *Client) pflowConcatAndDecrypt(pflow1, pflow2 []byte) (*protocol.HandShakeMsg, error) {
	enc_flow := append(pflow1, pflow2...)
	flow, err := c.AsymmCipher.PemDecrypt(enc_flow)
	if err != nil {
		c.MiProxy.CloseAll()
		return nil, defErr.StrConcat(
			protocol.C_PREFIX+protocol.BILATERY_PEM_DECRYPTION_FAILED,
			err)
	}
	presessionkey, err := c.extractHandShakeMsg(flow)
	if err != nil {
		c.MiProxy.CloseAll()
		return nil, err
	}
	return presessionkey, nil
}

// step 9: verify sign and check hash
func (c *Client) recheckHash(presessionkey *protocol.HandShakeMsg) error {
	verified := c.ProxyAsymmCipher.PubVerify(presessionkey.Hasher, presessionkey.Signature)
	if !verified {
		c.MiProxy.CloseAll()
		return errors.New(protocol.BILATERY_SIGNATURE_FAILURE)
	}
	hashX := utils.Uint64ToLittleEndianBytes(presessionkey.Nonce)
	hashX = append(hashX, presessionkey.Kern...)
	hashX = append(hashX, presessionkey.Timestamp...)
	recheck_hash := c.HashCipher.CalculateHash(hashX)
	status, descript := utils.CompareByteSliceEqualOrNot(recheck_hash, presessionkey.Hasher)
	if !status {
		c.MiProxy.CloseAll()
		return errors.New(protocol.C_PREFIX + protocol.BILATERY_HASH_ACK_FAILURE + descript)
	}
	return nil
}

// step 10: generate sessionKey and wait for rn
func (c *Client) readChallenge(preKey *protocol.HandShakeMsg) error {
	rn := c.rn
	keyIvLen := c.StreamCipher.GetKeyIvLen()
	tmpKey := protocol.GenerateSessionKey(
		[]byte(preKey.Kern[:c.KeyLen]),
		rn.Kern,
		rn.Nonce,
		preKey.Nonce,
		c.StreamCipher,
		c.HashCipher,
	)
	c.StreamCipher.SetKey(tmpKey)
	c.StreamCipher.SetIv(preKey.Kern[c.KeyLen:keyIvLen])
	resp_rn, _, err := c.DecRead()
	status, _ := utils.CompareByteSliceEqualOrNot(resp_rn, rn.Kern)
	if !status {
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.INCONSISTENCY_OF_RN, err)
	}
	return nil
}

func (c *Client) writeFinish() error {
	curr, res := protocol.AckToTimestampHash(c.HashCipher, []byte(protocol.HANDHLT))
	cnt, err := c.EncWrite(append(curr, res...))
	currLen := protocol.SafeGainTimestampHashLen() + c.StreamCipher.WithIvAttached()
	if uint64(cnt) != currLen || err != nil {
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.C_PREFIX+protocol.BILATERY_ACK_FINISHED_FAILURE, err)
	}
	return nil
}

// step 12 read finish
func (c *Client) readFinish() error {
	_finish, _, err := c.DecRead()
	if !protocol.AckFlowValidation(
		c.HashCipher, _finish,
		[]byte(protocol.HANDHLT),
		c.ackTimCheck, &c.ackRec, c.pingRef, false) || err != nil {
		c.MiProxy.CloseAll()
		return defErr.StrConcat(protocol.C_PREFIX+protocol.BILATERY_ACK_FINISHED_FAILURE, err)
	}
	return nil
}

func (c *Client) shakeHandReadCoroutine() (rerr error) {
	if !<-c.wNotifiedSignal {
		rerr = errors.New(protocol.C_PREFIX + protocol.BILATERY_INVALID_HELLO)
		return
	}

	rerr = c.readStep1()
	if rerr != nil {
		return
	}
	rerr = c.readStep2()
	if rerr != nil {
		return
	}
	rerr = c.readStep3( /* 1 read ackcflow1 */ )
	if rerr != nil {
		return
	}
	pflow1, rerr := c.readStep4() // read pflow1
	if rerr != nil {
		return
	}
	rerr = c.readStep3( /*2 read ackcflow2 */ )
	if rerr != nil {
		return
	}
	pflow2, rerr := c.readStep4() // read pflow2
	if rerr != nil {
		return
	}
	presessionkey, rerr := c.pflowConcatAndDecrypt(pflow1, pflow2)
	if rerr != nil {
		c.wNotifiedSignal <- false
		return
	}
	rerr = c.recheckHash(presessionkey)
	if rerr != nil {
		c.wNotifiedSignal <- false
		return
	}
	rerr = c.readChallenge(presessionkey)
	if rerr != nil {
		c.wNotifiedSignal <- false
		return
	}
	c.wNotifiedSignal <- true
	rerr = c.readFinish()
	return
}

func (c *Client) shakeHandWriteCoroutine() (werr error) {
	if config.GlobalClientConfiguration == nil {
		werr = errors.New(`configuration has not been set up`)
		c.wNotifiedSignal <- false
		c.MiProxy.CloseAll()
		return
	}
	asym_cfg := config.GlobalClientConfiguration.Local.AsymmetricCipher
	flow_cfg := config.GlobalClientConfiguration.Local.StreamCipher
	hash_cfg := config.GlobalClientConfiguration.Local.HashCipher
	zip_cfg := config.GlobalClientConfiguration.Local.CompressedAlgorithm
	access_token := config.GlobalClientConfiguration.Local.AccessToken

	werr = c.SendClientHelloPayload(asym_cfg, flow_cfg, hash_cfg, zip_cfg, access_token)
	if werr != nil {
		c.wNotifiedSignal <- false
		c.MiProxy.CloseAll()
		return
	}
	c.wNotifiedSignal <- true
	werr = c.writeStep1()
	if werr != nil {
		return
	}
	werr = c.writeStep2()
	if werr != nil {
		return
	}
	c.rn, werr = c.generateRN()
	if werr != nil {
		c.MiProxy.CloseAll()
		return
	}
	enc_rn, err := c.pPubEncryptHandShakeMsg(c.rn)
	if err != nil {
		c.MiProxy.CloseAll()
		return
	}
	flow1, flow2 := utils.BytesSpliterInHalfChanceField(enc_rn)
	werr = c.writeStep3(flow1, 1 /* send cflow1 */)
	if werr != nil {
		return
	}
	werr = c.writeStep4(1 /* send ackpflow1 */)
	if werr != nil {
		return
	}
	werr = c.writeStep3(flow2, 2 /* send cflow2 */)
	if werr != nil {
		return
	}
	werr = c.writeStep4(2 /* send ackpflow2 */)
	if werr != nil {
		return
	}
	if !<-c.wNotifiedSignal {
		werr = errors.New(`handshake failed in the middle knowing from reader coroutine`)
		return
	}
	werr = c.writeFinish()
	return
}

func (c *Client) clientAddrSpliter() (string, string) {
	domain := c.MiProxy.Conn.RemoteAddr().String()
	pos := 0
	for i := len(domain) - 1; i > 0; i-- {
		if domain[i] == ':' {
			pos = i
			break
		}
	}
	return domain[:pos], domain[pos:]
}

/*
todo: `ping` is not the final silver bullet for network connectivity due to several ineluctable issues.

	we need other protocols to dress up as pingers or resolve conflicts on current spot.
	Model-Free Adaptive Predictive Control... ?
*/
func (c *Client) Shakehand() (werr error, rerr error) {
	ip, _ := c.clientAddrSpliter()
	ping_ref, ok := service.PingWithoutPrint(ip, 3, 4, 5, 5)
	if !ok {
		werr = errors.New(protocol.BILATERY_FAILED_TO_PING)
		rerr = errors.New(protocol.BILATERY_FAILED_TO_PING)
		return
	}
	c.pingRef = ping_ref
	functor := func() { c.ackTimCheck, c.ackRec = new([8][]byte), 0 }
	wch, rch := make(chan error), make(chan error)
	functor()
	defer functor()
	go func() { rch <- c.shakeHandReadCoroutine(); close(rch) }()
	go func() { wch <- c.shakeHandWriteCoroutine(); close(wch) }()
	werr, rerr = <-wch, <-rch
	return
}
